<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="김재연">

<title>미국 테뉴어 트랙 잡 오퍼 협상 – 미국 아카데믹 커리어를 위한 조언</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">미국 아카데믹 커리어를 위한 조언</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">소개</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter1.html"> 
<span class="menu-text">박사 논문 커미티</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter2.html"> 
<span class="menu-text">발제와 토론</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter3.html"> 
<span class="menu-text">연구 생산성</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter4.html"> 
<span class="menu-text">네트워킹</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter5.html"> 
<span class="menu-text">잡마켓</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter6.html"> 
<span class="menu-text">잡톡</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./chapter7.html" aria-current="page"> 
<span class="menu-text">오퍼 협상</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./conclusion.html"> 
<span class="menu-text">마무리하며</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./license.html"> 
<span class="menu-text">라이선스</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#체어로부터-오퍼를-받았습니다.-협상을-해야-할까요" id="toc-체어로부터-오퍼를-받았습니다.-협상을-해야-할까요" class="nav-link active" data-scroll-target="#체어로부터-오퍼를-받았습니다.-협상을-해야-할까요">1. 체어로부터 오퍼를 받았습니다. 협상을 해야 할까요?</a></li>
  <li><a href="#협상은-종합적으로-하시길-추천합니다." id="toc-협상은-종합적으로-하시길-추천합니다." class="nav-link" data-scroll-target="#협상은-종합적으로-하시길-추천합니다.">2. 협상은 종합적으로 하시길 추천합니다.</a></li>
  <li><a href="#협상의-시작은-거절을-받는-것입니다" id="toc-협상의-시작은-거절을-받는-것입니다" class="nav-link" data-scroll-target="#협상의-시작은-거절을-받는-것입니다">3. 협상의 시작은 ’거절’을 받는 것입니다</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">미국 테뉴어 트랙 잡 오퍼 협상</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">저자</div>
    <div class="quarto-title-meta-contents">
             <p><a href="https://jaeyk.github.io">김재연</a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">공개</div>
    <div class="quarto-title-meta-contents">
      <p class="date">2025년 5월 8일</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>먼저 테뉴어 트랙 잡 오퍼를 받으신 것을 축하합니다.</p>
<p>이 장에서는 미국 대학에서 테뉴어 트랙 잡 오퍼를 받고 협상할 때 고려할 포인트를 정리해 보았습니다.</p>
<section id="체어로부터-오퍼를-받았습니다.-협상을-해야-할까요" class="level2">
<h2 class="anchored" data-anchor-id="체어로부터-오퍼를-받았습니다.-협상을-해야-할까요">1. 체어로부터 오퍼를 받았습니다. 협상을 해야 할까요?</h2>
<p>미국 대학에서 테뉴어 트랙 오퍼를 받으면, 협상은 통념적으로 기대되는 절차입니다.</p>
<p>협상의 목표는 지원자가 테뉴어 트랙에서 성공하기 위해 지원자와 학과가 모두 윈-윈하는 환경을 만드는 데 있습니다. 협상을 하는 것이 결과적으로 양쪽 모두에게 좋은 일입니다. 연구 환경이 개선되어 지원자가 연구를 더 잘하게 된다면, 해당 지원자가 테뉴어를 받을 가능성이 높아지겠죠. 학과가 지원자가 제공하는 가치에 걸맞은 대가를 지불하고, 지원자의 우선순위를 이해한다는 인상을 준다면, 해당 지원자의 리텐션 가능성이 높아집니다. 테뉴어 트랙 후보자를 검증하고 선발하는 데에는 많은 비용이 들며, 비슷한 라인이 이후에 나올 수도 있는 상황입니다. 지원자가 테뉴어를 받고 리텐션되는 것은 지원자와 학과 모두에게 중요하고 가치 있는 목표입니다.</p>
<p>또한, 협상을 해야 하는 중요한 현실적 이유는 학과가 제시하는 이니셜 오퍼가 최선의 오퍼가 아닌 경우가 많기 때문입니다. 지원자가 협상을 하지 않을 것을 염두에 두고(잡 마켓 경험이 적거나 아웃사이드 오퍼가 없거나 리텐션 오퍼를 받을 상황이 아니라서), 학과에서 줄 수 있는 것보다 낮춰서 제시하는 경우가 많습니다. 혹은 체어가 더 줄 수 있다는 점을 인지하지 못했다가, 협상 과정에서 깨닫는 경우도 있습니다. 체어가 안 된다고 생각했는데, 협상할 때 딘에게 얘기해 보니 딘이 된다고 해서 되는 경우도 있죠.</p>
<p>마지막으로, 협상을 해야 하는 중요한 이유는 체어와 여러 조건에 대해 이야기하다 보면, 캠퍼스 비짓시 알지 못했던 학교와 학과의 다양한 사정(어떤 부분에 내가 생각한 것보다 자원이 더 많다든지, 어떤 부분에 더 제약이 많다든지)을 이해하게 되기 때문입니다. 이는 협상한 조건이 내가 생각한 유리한 방향으로 흘러가든 그렇지 않든, 알아두면 유용한 정보입니다.</p>
<p>이니셜 오퍼는 체어가 전화로 해주는 경우가 많은데, 이때 바로 승낙할 필요는 없습니다. “고맙다”, “너의 동료가 될 가능성에 기대된다” 등의 통상적인 답례를 하고, 대신 구체적인 조건들은 서면으로 받은 뒤 종합적으로 검토해 회신하면 됩니다. 오퍼를 받은 당시에 결정하지 않아도 체어는 충분히 이해합니다. 제 경우는 고려 사항이 많아 오퍼를 받고 한 달 가까이 협상을 했습니다. 일반적으로, 학과에서 오퍼를 준 지원자에게 적어도 1~2주는 협상할 시간을 줍니다.</p>
</section>
<section id="협상은-종합적으로-하시길-추천합니다." class="level2">
<h2 class="anchored" data-anchor-id="협상은-종합적으로-하시길-추천합니다.">2. 협상은 종합적으로 하시길 추천합니다.</h2>
<p>체어에게 전화로 “축하한다”와 함께 “너에게 오퍼를 준다”는 전화 통보를 받고 당일, 혹은 늦어도 1~2일 내로 구체적인 조건을 적은 이메일이 옵니다.</p>
<p>버발로 오퍼를 받은 자리에서 승낙하는 것은 당연히 좋지 않으며, 서면 오퍼를 받은 후에도 조건을 하나씩 나눠서 협상하는 것은 좋지 않습니다.</p>
<p>협상은 충분한 정보를 수집한 후 종합적으로 진행하시길 추천합니다. 예를 들어, 학과가 서면 오퍼를 받고 승낙하기까지 2주의 시간을 준다고 가정합시다. 사실, 이 데드라인도 보통 소프트 데드라인인 경우가 많아 약간 연장이 가능합니다. 시간이 부족하다고 느끼시면, 이건 중요한 결정이므로 가족과 상의해야 해서 조금만 더 시간을 달라고 말씀하셔도 됩니다.</p>
<p>그 주어진 시간 내에 서치 커미티나 캠퍼스 비짓 시 만났던 특히 쥬니어 패컬티들에게 연락하여, 우선 “좋게 봐줘서 감사하다”고 이야기한 후, 오퍼에 대해 흥미는 있으나 최근 오퍼를 받은 사람들이 협상을 했는지, 어떤 부분에서 협상을 했는지 물어보세요. 거기서 어떻게, 얼마나 협상할 수 있는지에 대한 기본적인 정보를 얻을 수 있습니다. 일반적으로 지속적으로 제공되는 조건(샐러리)은 까다롭게 협상되는 경우가 많고, 일시적으로 제공되는 조건(1~2년 티칭 로드를 줄인다든지, 무빙 익스펜스를 늘린다든지) 등에 대해서는 좀 더 유연한 경우가 많습니다. 종합적으로 여러 조건을 고려할 때, 어떤 조건이 나(와 내게 소중한 사람들)에게 더 중요한지 그 우선순위를 결정하시길 바랍니다.</p>
<p>이렇게 정보 수집 후 종합적으로 협상하는 것이 중요한 이유는 제가 볼 때 세 가지가 있습니다.</p>
<ol type="1">
<li><p>이 과정에서 학과와 지원자 모두 서로 어디에 제약이 있는지, 우선순위가 무엇인지를 알게 됩니다. 이것 자체가 매우 유용합니다.</p></li>
<li><p>트레이드가 가능해집니다. 학과에게는 양보할 수 없는 조건이 지원자에게는 양보할 수 있는 조건인 경우가 있습니다. 트레이드가 쉬워지므로 패키지로 딜을 하는 것이 좋습니다.</p></li>
<li><p>나눠서 협상하면 협상 기간이 길어지고 양쪽 모두 피곤해집니다. 어차피 나중에 같이 일할 사람들이니 굳이 피곤한 상황을 만들 필요는 없습니다.</p></li>
</ol>
</section>
<section id="협상의-시작은-거절을-받는-것입니다" class="level2">
<h2 class="anchored" data-anchor-id="협상의-시작은-거절을-받는-것입니다">3. 협상의 시작은 ’거절’을 받는 것입니다</h2>
<p>“학과가 나를 원하는 만큼”, “내 가치를 인정해 주는 만큼” 나에게 바게닝 파워가 있습니다. 그래서 한 학과로부터 오퍼를 받았는데, 아직 인터뷰 일정이 있는 다른 학과가 있다면 가장 먼저 할 일은 그 다른 학과에 연락하여 다음 인터뷰 일정을 앞당기는 것입니다. 또한, 내가 1순위 지원자였다면 학과 내에서 얼마나 강력하게 나를 1순위로 꼽았는지, 그리고 2순위 지원자와 나 사이의 온도 차이가 어느 정도인지를 파악하는 것이 중요합니다. 내가 학과가 정말 원하는 인재라면 잠재적 바게닝 파워가 있습니다. 아웃사이드 오퍼나 리텐션 오퍼가 있다면 명확한 바게닝 칩이 있는 것입니다.</p>
<p>나에게 어느 정도 바게닝 파워가 있는지 파악했다면, 그 정도를 기준으로 카운터 오퍼를 제시하시길 바랍니다. 상대방이 “이 정도면 받아들이겠다”가 아니라, 조금 더 높은 조건, “이 정도면 거절하겠다”고 생각하는 기준으로 제시해야 합니다.</p>
<p>내가 학과로부터 어떤 조건에서, 얼마나 받을 수 있을지는 협상이 끝나기 전까지는 알 수 없습니다. 일단 상대방이 “이건 안 된다”라고 해야 상한선을 파악할 수 있고, “안 된다”라고 하는 근거를 들어야 그 부분에 대해 다시 어떻게 협상해야 할지(혹은 하지 말아야 할지)에 대한 방향을 잡을 수 있습니다. 그래서 저는 협상의 시작은 일단 거절을 받는 것이라고 봅니다.</p>
<hr>
<p>마지막으로 유념해야 할 점은, 처음 오퍼를 준 학과에 가시든 아니면 다른 학과로 가시든, 결국 학계를 떠나지 않는 이상 이 분들은 계속 만나게 될 사람들이라는 점입니다. 내가 원하는 조건을 상대방에게 강요하기보다는, 먼저 존중하고 이해하며 서로 윈-윈할 수 있는 방향과 조건을 찾아 나가시길 추천합니다.</p>
<p>좋은 협상은 협상의 과정과 결과를 통해 상호 존중과 신뢰가 더욱 깊어지는 협상입니다.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>