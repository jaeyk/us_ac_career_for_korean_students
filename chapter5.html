<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="김재연">

<title>미국 아카데믹 잡마켓 준비 – 미국 아카데믹 커리어를 위한 조언</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">미국 아카데믹 커리어를 위한 조언</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">소개</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter1.html"> 
<span class="menu-text">박사 논문 커미티</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter2.html"> 
<span class="menu-text">발제와 토론</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter3.html"> 
<span class="menu-text">연구 생산성</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter4.html"> 
<span class="menu-text">네트워킹</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./chapter5.html" aria-current="page"> 
<span class="menu-text">잡마켓</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter6.html"> 
<span class="menu-text">잡톡</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter7.html"> 
<span class="menu-text">오퍼 협상</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./conclusion.html"> 
<span class="menu-text">마무리하며</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./license.html"> 
<span class="menu-text">라이선스</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#왜-잡마켓은-힘든가" id="toc-왜-잡마켓은-힘든가" class="nav-link active" data-scroll-target="#왜-잡마켓은-힘든가">왜 잡마켓은 힘든가?</a></li>
  <li><a href="#who-am-i-one-liner" id="toc-who-am-i-one-liner" class="nav-link" data-scroll-target="#who-am-i-one-liner">1. “Who am I?” (One-liner)</a></li>
  <li><a href="#who-am-i-becoming-23-sentences" id="toc-who-am-i-becoming-23-sentences" class="nav-link" data-scroll-target="#who-am-i-becoming-23-sentences">2. “Who am I becoming?” (2–3 sentences)</a></li>
  <li><a href="#what-is-my-fit-12-good-questions" id="toc-what-is-my-fit-12-good-questions" class="nav-link" data-scroll-target="#what-is-my-fit-12-good-questions">3. “What is my fit?” (1–2 good questions)</a></li>
  <li><a href="#마무리-잡마켓-준비는-재즈처럼" id="toc-마무리-잡마켓-준비는-재즈처럼" class="nav-link" data-scroll-target="#마무리-잡마켓-준비는-재즈처럼">마무리: 잡마켓 준비는 재즈처럼</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">미국 아카데믹 잡마켓 준비</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">저자</div>
    <div class="quarto-title-meta-contents">
             <p><a href="https://jaeyk.github.io">김재연</a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">공개</div>
    <div class="quarto-title-meta-contents">
      <p class="date">2025년 5월 8일</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>미국 아카데믹 잡 마켓 준비에 대한 조언을 적어 봅니다.각자의 상황이 다르기 때문에 아래의 조언은 그 한계를 고려하여 적절하게 수용하고 적용하시길 추천합니다.</p>
<section id="왜-잡마켓은-힘든가" class="level2">
<h2 class="anchored" data-anchor-id="왜-잡마켓은-힘든가">왜 잡마켓은 힘든가?</h2>
<p>아카데믹 잡 마켓이 힘든 가장 근본적 이유는 잡은 적고, 잘 하는 사람은 많기 때문입니다. 부가적인 이유는 많은 지원자들이 “연구를 잘 하는 것”과 “잡을 얻는 것”이 완벽하게 상관되어 있다고 믿기 때문입니다. 당연히 둘은 양의 상관관계가 있으나 그 상관계수는 1이 아닙니다.</p>
<p>연구를 잘 하는 것은 필요 조건이지만 충분 조건은 아닙니다. 내가 잘 하는 만큼이 아니라, 내가</p>
<ul>
<li><p>(1) “잘 하는 것”, (과거와 현재)</p></li>
<li><p>(2) “잘 할 것”을, (미래)</p></li>
<li><p>(3) “잘 커뮤니케이션”한 만큼</p>
<p>좋은 인상을 줍니다.</p></li>
</ul>
<p>그 인상을 바탕으로 서치 커미티가 이 지원자가 “잘 하고, 잘 할 것이고, 핏이 맞는다”라고 인식한 만큼 잡 오퍼를 받을 확률이 높아집니다. 춤은 두 사람이 같이 춰야 합니다.</p>
<p>이 커뮤니케이션 목표를 바쁘고 귀찮은 사람들(=서치 커미티)을 대상으로 달성하는 것은 어렵습니다. 그래서 잡 마켓은 어렵고, 많은 준비와 노력, 연습이 필요합니다.</p>
<p>나아가, 대학에서 교원 채용을 위한 “서치”가 어떻게 이뤄지는지를 생각해 볼 필요가 있습니다. 서치 커미티에 들어오는 교수들은 꼭 그 해 라인이 나온 분야에서 학과 내 가장 적절한 전문가들만은 아닙니다. 그런 분들도 있지만, 어쩌다 그 해 그 서비스를 해야 해서 참여하게 된 분들도 있습니다. 특정 서치가 공고되어 나오는 것은 결국 학과와 행정 간의 협상 결과입니다. 따라서 공고문에 있는 내용을 실제 학과의 수요로 문자 그대로 해석하는 것은 무리가 있습니다. 상대방의 필요를 파악해야 어떻게 커뮤니케이션할지 전략을 세울 수 있는데, 그 탐색 과정에서도 이미 많은 노이즈와 부정확한 시그널을 마주치게 됩니다.</p>
<p>위와 같은 제약 조건 하에서 서치 커미티에게 “내가 학과가 원하는 올해 최고의 지원자”임을 커뮤니케이션하기 위해, 제 의견에 따라 생각해 볼 만한 지점들을 아래 세 가지로 정리해 보았습니다.</p>
</section>
<section id="who-am-i-one-liner" class="level2">
<h2 class="anchored" data-anchor-id="who-am-i-one-liner">1. “Who am I?” (One-liner)</h2>
<p>서치 커미티들은 기본적으로 매우 바쁩니다. 자기 연구도 하고, 수업도 가르치며, 학생 지도까지 해야 하는 와중에 서치 커미티에 참여해야 하기 때문입니다. 경쟁력 있는 학과라면 한 라인에 지원자가 수백 명이 넘습니다. 서치 커미티는 그 많은 지원자들 중에서 롱리스트와 숏리스트를 만들고, 줌 인터뷰를 진행하며, 지원자가 캠퍼스 인터뷰에 올 경우 잡 톡을 포함한 여러 번의 미팅과 때로는 식사까지 진행합니다.</p>
<p>이 바쁘고 귀찮은 사람들을 위해 나는 “어떤 학자다”라는 것을 단 한 문장(one-liner)으로 정리해 설명할 수 있어야 합니다. 이 내용은 잡 마켓 패킷(커버 레터 등), 개인 홈페이지, 잡 톡, 그리고 패컬티와 1:1 미팅 시 모두 일관되게 언급되어야 합니다. 그렇게 해야 서치 커미티와 학과 교수들이 “특정 분야를 연구하는 사람이다”라는 인상을 머릿속에 남길 수 있습니다. 남이 나를 정의하기 전에, 내가 나를 정의하는 것은 대화의 우선권을 잡기 위한 중요한 전략입니다.</p>
<p>다만, 학과도 다양하고 특정 채용 공고가 나오는 이유도 다르므로, 내가 “어떤 학자다”라고 어필하는 방식은 그 맥락에 따라 달라져야 합니다. 저는 2024년 아카데믹 잡 마켓에서 정책과 데이터 과학 잡에 모두 지원했는데, 정책학 인터뷰에서는 어떤 분야의 정책을 연구하는지를, 데이터 과학 인터뷰에서는 어떤 분야의 데이터 과학을 연구하는지를 각각 어필했습니다.</p>
<p>여기서 중요한 것은 서치 커미티가 “내가 어떤 분야를 연구하는 학자”라는 이야기를 들었을 때, “이 분이 우리 학과에서 필요한 학자”라는 인식을 가져야 한다는 점입니다.</p>
<p>달리 말하면, 서치 커미티가 “어떤 분야를 연구하는 학자이십니까?”라고 질문할 때, 그 기저에는 “우리가 뽑으려는 분야의 학자이십니까?”라는 질문이 숨어 있습니다. 이 차이를 염두에 두어야 합니다.</p>
</section>
<section id="who-am-i-becoming-23-sentences" class="level2">
<h2 class="anchored" data-anchor-id="who-am-i-becoming-23-sentences">2. “Who am I becoming?” (2–3 sentences)</h2>
<p>잡 마켓에 나오기 전까지 지난 시간 동안 많은 노력과 수고를 했을 것입니다. 그러나 학과가 교원을 채용할 때는 그 사람의 과거를 보고 인터뷰에 초청하지만, 그 사람의 미래를 보고 오퍼를 제공합니다. 오퍼는 투자입니다. 따라서 나의 과거와 현재뿐만 아니라, 나의 미래와 잠재성을 설명하는 것이 매우 중요합니다. 그래서 줌 인터뷰에서 거의 반드시 나오는 질문 중 하나가 향후 3–5년 동안 어떤 연구를 할 것인지에 관한 것입니다.</p>
<p>Who am I becoming?”에 답하는 원칙도 “Who am I?”에 답하는 원칙과 비슷합니다. 앞에서는 한 문장을 통해 “내가 어떤 분야를 연구하는 학자다”를 강조했다면, 여기서는 2–3 문장을 통해 내가 “어떤 분야에서 유망할 학자다”라는 점을 강조해야 합니다.</p>
<p>이 포인트가 중요한 이유는 여러 가지가 있습니다.</p>
<p>첫 번째, 전임 트랙에서 교원을 뽑을 경우 이 사람이 몇 년 후 테뉴어를 받을 수 있을 것을 전제로 합니다. 미국의 연구 중심 대학에서 테뉴어를 받으려면 그 분야에서 유망한 학자가 되어야 합니다. 학과는 지원자가 지금까지 잘한 것 때문에 잡 인터뷰 요청을 하지만, 테뉴어 트랙 지원자를 대상으로 인터뷰할 때는 이 사람이 테뉴어를 받을 수 있을지 판단해야 합니다. 이때 후속 연구, 즉 리서치 파이프라인의 가능성과 잠재적 임팩트를 보여주는 것이 중요합니다.</p>
<p>두 번째, 지금까지 연구한 분야가 채용 공고의 핏과 잘 맞지 않더라도, 앞으로 연구할 분야가 채용 공고의 핏과 어떻게 맞는지 설명할 수 있습니다. 따라서 이 질문은 내 핏을 한 번 더 설명할 수 있는 매우 좋은 기회입니다.</p>
</section>
<section id="what-is-my-fit-12-good-questions" class="level2">
<h2 class="anchored" data-anchor-id="what-is-my-fit-12-good-questions">3. “What is my fit?” (1–2 good questions)</h2>
<p>인터뷰 과정에서는 반드시 서치 커미티에게 질문할 기회가 주어집니다. 줌 인터뷰에서나 캠퍼스 인터뷰에서나, 혹은 평소 대화 중에도 상대방의 질문을 통해 그 사람이 얼마나 대화에 집중하고 있으며 나에게 관심이 있는지 알 수 있습니다. 이 질문 기회는 내가 학과에 얼마나 관심이 있는지를 보여줄 수 있는 좋은 기회입니다.</p>
<p>저는 거의 모든 줌 인터뷰에서 학과가 어떤 학자를 뽑으려 하는지에 대해 서치 커미티에게 물었습니다. 보통 이 시점이면 제 연구 분야, 앞으로 연구할 분야, 가르칠 과목, 학생 지도 방법 등을 설명한 후입니다. 이때 서치 커미티가 본인들 입장에서 핏을 설명하는데, 내가 설명한 핏과 맞지 않다면 내 노력이 실패한 것이고, 맞다면 내가 잘한 부분이 있는 것입니다. 놓친 부분이 있다면 향후 수정해야 합니다.</p>
<p>위의 질문을 제외하면, 줌 인터뷰나 캠퍼스 인터뷰에서 나머지 질문들은 서치 커미티가 (1) 적극적이고 (2) 긍정적으로 대답할 수 있는 질문 위주로 진행됩니다. <strong>서치 커미티는 지원자가 어떤 질문을 했는지보다, 그 질문에 대해 대답했을 때 어떤 기분을 느꼈는지를 기억합니다.</strong> 그래서 상대방의 입장에서 어떤 질문을 할지 신중하게 생각하는 것이 필요합니다.</p>
<p>예를 들어, 학제간 연구가 활발한 학과라면 학제간 연구 지원에 관한 구체적인 질문을 하는 것이 좋습니다. 이러한 내용은 학과 홈페이지나 서치 커미티에 속한 교수들의 홈페이지에서 쉽게 확인할 수 있으며, 학제간 연구가 활발하지 않은 학과라면 이러한 질문은 피하는 것이 좋습니다.</p>
<p>내가 질문할 기회가 주어졌을 때는, 내가 그 학과에 얼마나 관심이 있는지를 보여줄 수 있는 좋은 기회입니다. “더 질문할 것이 있냐?”는 질문은 “너가 우리에게 얼마나 관심 있니? 우리를 잘 이해하고 있니?”라는 질문과도 같습니다.</p>
</section>
<section id="마무리-잡마켓-준비는-재즈처럼" class="level2">
<h2 class="anchored" data-anchor-id="마무리-잡마켓-준비는-재즈처럼">마무리: 잡마켓 준비는 재즈처럼</h2>
<p>대화의 상대방에 따라 대화의 방향과 방식은 달라질 수밖에 없습니다. 잡 마켓에 나오면 경쟁이 치열하기 때문에 여러 학교와 학과에 지원해야 합니다. 이렇게 많은 학교와 학과에 대해 맞춤형 커뮤니케이션을 준비하다 보면 상당한 시간, 노력, 연습이 필요합니다.</p>
<p>여기서 중요한 것은 내가 어떤 질문에 어떻게 답변할지를 미리 준비해보되, 그 대본 그대로 따라가기보다는 유연하게 대응하는 것입니다. 내가 예상한 대로 상황이 전개되는 경우는 드물기 때문입니다. 따라서 잡 마켓에서 해야 할 커뮤니케이션은 고전 음악보다는 재즈 음악을 연주하는 것과 비슷합니다. 주어진 상황에서 어떤 말을 어떻게 할 것인지에 대한 기본적인 전략은 필요하지만, 응용력이 더욱 중요합니다.</p>
<p>부단한 노력에도 불구하고 잡 마켓은 근본적으로 만만하지 않기 때문에 많은 불확실성을 견뎌내야 하고, 거절을 경험해야 합니다. 그 와중에 노이즈도 있지만 유용한 데이터 포인트도 있으니, 이를 잘 구분하시길 추천합니다.</p>
<p>우리는 기계가 아니라 사람이기에 잡 마켓 탐색 과정에서 스트레스가 심하고, 그로 인해 정신 건강에 악영향을 받을 수 있습니다. 장기전을 위해 스트레스를 잘 관리하는 습관을 만드는 것이 중요합니다. 건강하게 식사하고, 숙면을 취하며, 정기적으로 운동하고, 무엇보다 서포트 그룹을 통해 필요한 정서적 위로, 지속적 지지, 전략적 조언을 받으시길 추천합니다. 그 어느 때보다 Lean On(린 온)할 때입니다.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>