<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="김재연">

<title>박사 논문 커미티 만들기 – 미국 아카데믹 커리어를 위한 조언</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">미국 아카데믹 커리어를 위한 조언</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">소개</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./chapter1.html" aria-current="page"> 
<span class="menu-text">박사 논문 커미티</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter2.html"> 
<span class="menu-text">발제와 토론</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter3.html"> 
<span class="menu-text">연구 생산성</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter4.html"> 
<span class="menu-text">네트워킹</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter5.html"> 
<span class="menu-text">잡마켓</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter6.html"> 
<span class="menu-text">잡톡</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chapter7.html"> 
<span class="menu-text">오퍼 협상</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./conclusion.html"> 
<span class="menu-text">마무리하며</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./license.html"> 
<span class="menu-text">라이선스</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#내-박사-논문은-내가-쓴다.-지도교수의-손은-거들-뿐." id="toc-내-박사-논문은-내가-쓴다.-지도교수의-손은-거들-뿐." class="nav-link active" data-scroll-target="#내-박사-논문은-내가-쓴다.-지도교수의-손은-거들-뿐.">1. 내 박사 논문은 내가 쓴다. 지도교수의 손은 거들 뿐.</a>
  <ul class="collapse">
  <li><a href="#미팅-주기" id="toc-미팅-주기" class="nav-link" data-scroll-target="#미팅-주기">미팅 주기</a></li>
  <li><a href="#자료-공유-및-이메일-커뮤니케이션" id="toc-자료-공유-및-이메일-커뮤니케이션" class="nav-link" data-scroll-target="#자료-공유-및-이메일-커뮤니케이션">자료 공유 및 이메일 커뮤니케이션</a></li>
  <li><a href="#미팅-커뮤니케이션" id="toc-미팅-커뮤니케이션" class="nav-link" data-scroll-target="#미팅-커뮤니케이션">미팅 커뮤니케이션</a></li>
  <li><a href="#프로젝트-매니지먼트" id="toc-프로젝트-매니지먼트" class="nav-link" data-scroll-target="#프로젝트-매니지먼트">프로젝트 매니지먼트</a></li>
  </ul></li>
  <li><a href="#박사-논문-체어의-가장-중요한-역할은-좋은-추천서를-써주는-것." id="toc-박사-논문-체어의-가장-중요한-역할은-좋은-추천서를-써주는-것." class="nav-link" data-scroll-target="#박사-논문-체어의-가장-중요한-역할은-좋은-추천서를-써주는-것.">2. 박사 논문 체어의 가장 중요한 역할은 좋은 추천서를 써주는 것.</a></li>
  <li><a href="#커미티-멤버는-작을수록-좋다." id="toc-커미티-멤버는-작을수록-좋다." class="nav-link" data-scroll-target="#커미티-멤버는-작을수록-좋다.">3. 커미티 멤버는 작을수록 좋다.</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">박사 논문 커미티 만들기</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">저자</div>
    <div class="quarto-title-meta-contents">
             <p><a href="https://jaeyk.github.io">김재연</a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">공개</div>
    <div class="quarto-title-meta-contents">
      <p class="date">2025년 5월 8일</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>미국의 연구 중심 대학에 소속된 교수 입장에서 보면, 연구가 본업이고 티칭은 부업입니다. 연구를 잘 해야 잡을 얻고(테뉴어를 포함한) 승진할 수 있습니다. 티칭을 할 줄 알아야 학교와 학과에서 맡은 책임을 다할 수 있습니다.</p>
<p>연구와 티칭에 비해 학생 지도는 사실 교수의 의무라기보다 선택에 가깝습니다. 교수에게 학생을 지도하는 데 많은 시간과 노력이 들어가지만, 그에 대한 제도적 보상은 매우 작기 때문입니다. 그럼에도 불구하고 교수들이 학생을 지도하는 이유는 잠재력 있는 학생을 발굴하고 그들의 커리어를 지지하는 데서 오는 보람 때문입니다.</p>
<p>반대로, 박사 과정에 있는 학생 입장에서 보면 지도교수를 찾고 정하는 문제는 결코 가벼운 문제가 아닙니다. 단적으로, 지도교수를 정하지 못하면 학위를 마칠 수 없기 때문입니다.</p>
<p>박사 과정에서 큰 스트레스 중 하나는 ’박사 논문 커미티(dissertation committee)’를 구성하는 일입니다. 흔히 커미티를 “정한다”는 표현을 쓰지만, 실제로는 정하는 것이 아니라, 잠재적인 지도교수와 학생 사이에 이해관계가 맞아떨어져야 성사됩니다. 거기에 신뢰 관계까지 쌓여야 비로소 좋은 커미티가 만들어집니다.</p>
<p>문제는 공급자는 마음이 차갑고, 수요자는 마음이 뜨겁다는 데 있습니다. 그래서 커미티를 구성하는 일은 근본적으로 ‘매칭’ 문제이며, 시작부터 결코 만만하지 않습니다.</p>
<p><strong>박사 논문 커미티는 무엇일까요? 어떻게 하면 좋은 커미티를 만들 수 있을까요?</strong></p>
<p>후배들에게 자주 해주던 조언들을 아래 세 가지로 정리해 보았습니다. 저는 사회과학자이므로 이 글은 사회과학 박사 과정에 계신 분들께 좀 더 적절할 수 있습니다. 또한 한국에서 대학원을 다닌 적이 없기 때문에, 이 글이 한국 대학원 박사 과정에도 적절할지에 대해서는 확신할 수 없습니다.</p>
<section id="내-박사-논문은-내가-쓴다.-지도교수의-손은-거들-뿐." class="level2">
<h2 class="anchored" data-anchor-id="내-박사-논문은-내가-쓴다.-지도교수의-손은-거들-뿐.">1. 내 박사 논문은 내가 쓴다. 지도교수의 손은 거들 뿐.</h2>
<div class="quarto-figure">
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="https://i.namu.wiki/i/U9keNwKNsCkrGtOIxOl28UVlARZRmuk2PKTtkKpn0L9X5QKs8y4RqrvR6kXd45X0AmB8C22_oAPLOiwEKZ2e0H7mW6xuGRmWgaDTKyxcGIbtlPZ4Fe0LHwnpQedCJU0IMmKFKvvKtNx3EmvQGQW4Gg.webp" class="img-fluid figure-img" width="300"></p>
<figcaption>슬램덩크의 명대사. 왼손은 거들 뿐. 출처: 나무위키</figcaption>
</figure>
</div>
</div>
<p>제가 경험한 한국 학생들의 가장 큰 장점이자 약점은 “착하고 성실하다”는 점입니다. 좀 더 냉정하게 말하면, 한국 학생들은 “지시하는 것은 잘하지만, 자기 주도적으로 문제를 정의하고 해결하는 능력은 부족합니다.” 왜 이런 현상이 나타나는가에 대해 문화적 차이로 설명할 수도 있겠지만, 저는 제도적 원인이 있다고 의심합니다. 제가 경험한 한국 교육 제도는 학생에게 주도적으로 문제를 정의하고 해결할 기회를 많이 주지 않았기 때문입니다.</p>
<p>이런 문화나 제도 속에서 자라다 보니, 많은 한국 학생들이 지도교수를 “지도해 주는 사람”, “이끌어 주는 사람”으로 정의하고 기대합니다. 이 말이 완전히 틀린 것은 아니지만, 완전히 맞는 말도 아닙니다.</p>
<p><strong>근본적으로, 내 박사 논문은 내 논문입니다. 만약 내 박사 논문이 스타트업이라면, 나는 스타트업 파운더이고 지도교수는 내 회사에 지분 투자를 한 보드 멤버 중 한 명이 될 것입니다. 중요한 의사결정을 효과적으로 내리기 위해 이 분들의 조언을 듣긴 하지만, 결국 내 사업이므로 최종 결정은 내가 내려야 합니다.</strong></p>
<p>구체적인 예를 들자면, 제 주도적으로 박사 논문을 쓰고 지도교수의 시간을 효율적으로 활용하기 위해 다음과 같은 방법들을 사용했습니다.</p>
<section id="미팅-주기" class="level3">
<h3 class="anchored" data-anchor-id="미팅-주기">미팅 주기</h3>
<ul>
<li><p>전 박사 논문을 쓸 때, 제가 주도해서 지도교수들의 미팅 케이던스를 정했습니다.</p></li>
<li><p>제가 있던 프로그램에서는 박사 3년차 때 ’박사 논문 프로스펙터스’라는, 박사 논문을 어떻게 쓰겠다는 사업계획서와 비슷한 문서를 한 학기 동안 작성해야 했습니다. 지도교수들이 매우 바쁘셔서, 이때는 무조건 격주에 한 번씩 뵙기로 제가 먼저 제안하여 일정을 잡았습니다. 그때는 지도교수들을 정말 자주 뵈었습니다.</p></li>
<li><p>막상 박사 논문을 시작한 후에는 프로스펙터스 작성 때처럼 자주 뵈지 않았습니다. 자료 수집과 논문 작성에 바빴기 때문입니다. 그때도 논문 진행 상황에 따라 한 달, 두 달, 한 학기 등 기간을 정해 논문 챕터를 보여주고 코멘트를 받은 후 수정하고, 다시 코멘트를 받는 방식으로 진행했습니다.</p></li>
</ul>
</section>
<section id="자료-공유-및-이메일-커뮤니케이션" class="level3">
<h3 class="anchored" data-anchor-id="자료-공유-및-이메일-커뮤니케이션">자료 공유 및 이메일 커뮤니케이션</h3>
<ul>
<li><p>미팅 일주일 전: 논문 챕터 등 지도교수들이 미리 읽으셨으면 좋겠다고 판단한 자료를 공유했습니다.</p></li>
<li><p>미팅 하루 전: 미팅 아젠다를 공유했고,</p></li>
<li><p>미팅 후: 회의 내용을 정리해 공유했습니다.</p></li>
<li><p>이메일 커뮤니케이션은 지도교수들의 읽는 시간을 줄이기 위해 모두 짧게 작성했습니다.</p></li>
</ul>
</section>
<section id="미팅-커뮤니케이션" class="level3">
<h3 class="anchored" data-anchor-id="미팅-커뮤니케이션">미팅 커뮤니케이션</h3>
<ul>
<li><p>미팅 시, 먼저 내가 문제라고 생각하는 것과 왜 그런 방식으로 문제를 풀려고 했는지를 짧게 설명하고, 교수님께서 이해하신 듯하면 내가 생각한 Plan A를 말씀드리고 그 장단점에 대해 토론했습니다.</p></li>
<li><p>만약 교수님께서 다른 의견을 가지시면 Plan B를 말씀드렸습니다.</p></li>
<li><p>Plan A로 간 적도, Plan B로 간 적도 있으며, 둘에 대해 열심히 논의하다가 이 둘도 아닌 새로운 길로 간 적도 있습니다.</p></li>
<li><p>내 논문이고 내 미팅이므로, 미팅은 내가 조직하고 진행하는 것이 맞다고 판단했습니다.</p></li>
</ul>
</section>
<section id="프로젝트-매니지먼트" class="level3">
<h3 class="anchored" data-anchor-id="프로젝트-매니지먼트">프로젝트 매니지먼트</h3>
<p>이와 같은 방식 덕분에 지도교수들은 제가 어떤 계획을 가지고, 어떻게 논문을 진행하고 있는지 파악할 수 있었습니다. 또한, (1) 주어진 미팅에서 어떤 주제와 문제를 논의하고 싶은지, (2) 주어진 피드백을 활용해 문제를 어떻게 해결하려 하는지를 쉽게 알 수 있었습니다.</p>
<p>왜 이렇게 했느냐? 크게 두 가지 이유가 있습니다.<br>
(1) 내 박사 논문은 내 논문이기 때문입니다. 내가 주도적으로 문제를 정의하고 해결하는 것이 당연합니다.<br>
(2) 내 지도교수들이 매우 바쁘시다는 것을 알고 있었기 때문입니다. 교수님들의 소중한 시간을 헛되게 쓰지 않기 위해, 내가 보내는 이메일과 자료는 간결하게 작성하고, 미팅에서는 핵심적인 내용만 전달하려 노력했습니다. 박사 논문 쓰기”라는 어려운 문제를 해결하기 위해 내가 쓸 수 있는 가장 비싸고 귀한 자원은 바로 내 분야의 권위자인 지도교수의 시간입니다.</p>
</section>
</section>
<section id="박사-논문-체어의-가장-중요한-역할은-좋은-추천서를-써주는-것." class="level2">
<h2 class="anchored" data-anchor-id="박사-논문-체어의-가장-중요한-역할은-좋은-추천서를-써주는-것.">2. 박사 논문 체어의 가장 중요한 역할은 좋은 추천서를 써주는 것.</h2>
<p>박사 논문 커미티에서 가장 중요한 사람은 체어입니다. 체어는 커미티 멤버 중에서 지도학생과 연구 핏이 가장 잘 맞는 사람이 되어야 하며, 무엇보다 나중에 아카데믹 잡을 지원할 때 이 분에게 추천서를 받아야 하기 때문입니다. 추천서는 다른 커미티 멤버나, 커미티 멤버가 아니더라도 설득력 있는 관계(예: 공저자)를 통해 받아도 됩니다. 그러나 졸업 전(ABD) 또는 박사 취득 후 포닥을 진행하면서 잡을 지원할 때, 박사 논문은 본인의 연구 성과에서 매우 중요한 위치를 차지합니다. 아직 연구 성과가 많지 않은 상태에서는 체어보다 더 좋은 연구 관련 레퍼런스를 줄 수 있는 사람이 많지 않습니다.</p>
<p>추천서가 왜 중요한지는 하이어링 커미티에서 확인할 수 있습니다. 추천서의 가장 큰 역할은 지원자의 연구 성과와 가능성을 추천자의 입장에서 다시 설명해 주는 것입니다. 지원자가 자기 연구 성과와 가능성을 스스로 잘 설명하지 못하는 경우가 많기 때문에, 다른 사람이 “이 친구 잘 한다, 잘 할 것이다”라고 말하는 것이 훨씬 설득력이 있습니다. 특히 추천인이 그 분야의 권위자라면 더욱 그러합니다(자신의 이름과 명성을 걸고 추천하는 것이므로). 그래서 추천서는 매우 중요하며, 하이어링 커미티에서 보면 생각보다 구체적이고 상세합니다. 추천서는 특히(아직 보여줄 연구 성과가 많지 않은 상태에서) 첫 잡을 잡을 때 정말 중요합니다.</p>
<p>이 추천서의 중요성을 고려하면, “박사 논문 커미티에서 체어는 누가 되어야 하느냐”라는 질문의 대답도 명확해집니다. 체어는 내가 속한 학과에서 나에게 가장 강력한 추천서를 써줄 수 있는 사람이어야 합니다.</p>
</section>
<section id="커미티-멤버는-작을수록-좋다." class="level2">
<h2 class="anchored" data-anchor-id="커미티-멤버는-작을수록-좋다.">3. 커미티 멤버는 작을수록 좋다.</h2>
<p>사실, 박사 논문에서 체어를 제외한 커미티 내 나머지 멤버들의 역할이 얼마나 중요한지는 본인에게 달려 있습니다. 내가 추천서를 받지 않을 것을 전제한다면, 나머지 패컬티와의 관계를 얼마나 깊이할 것인지는 본인의 선택입니다.</p>
<p>또한, 박사 논문 커미티에 공식적으로 포함되지 않아도, 학과 내외의 패컬티로부터 논문 코멘트를 받을 수 없는 것은 아닙니다. 대학원에 들어온 이후부터는 이미 학계의 일원입니다. 많은 박사 과정생들은 소수의 “공식” 지도교수와 다수의 “비공식” 자문위원, 혹은 조언단의 도움을 받아 논문을 작성합니다. 공식 지도교수는 훨씬 더 자주 피드백을 주고, 비공식 자문위원이나 조언단은 특정 분야나 문제에 대해 적은 빈도로 해결책을 제시합니다. 그래서 보통 박사 논문 감사의 글(acknowledgement)에는 지도교수 외에도 상당히 많은 이름이 등장합니다.</p>
<p>체어 외의 커미티 멤버의 역할은 상대적으로 덜 중요하지만, 그들의 영향력이 전혀 없는 것은 아닙니다. 나중에 학위 논문이 통과되려면 이들 모두의 서명이 필요하기 때문입니다. 만약 커미티 내 교수들 간의 의견 충돌이 잦을 것 같으면, 이를 조율하는 데 많은 시간과 노력이 들어갈 수 있습니다. 이런 문제를 인지하여, 서로 맞지 않는 교수들은 같은 커미티에 포함되는 것을 선호하지 않는 경우도 흔합니다.</p>
<p>그래서 제가 보통 추천하는 것은, 박사 학위 통과를 위한 최소한의 커미티(minimum winning coalition)를 구성하는 것입니다.</p>
<hr>
<p>미국의 연구 중심 대학에서 박사 과정을 시작하셨다면, 사실 학교가 아니라 직장을 다니는 것입니다. 그래서 교수들도 학생들에게 퍼스트 네임으로 부르라고 합니다. 같은 커뮤니티의 동료이기 때문입니다. 이 맥락에서, 지도교수는 내 보스가 아니라 “나의 가장 중요한 동료”입니다. 이 사실을 일찍 깨닫고 프로답게 생각하고 행동하면 박사 과정에서 겪을 불필요한 스트레스를 크게 줄일 수 있다고 믿습니다.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>